<html>
	<head>
		<title>Lab 1</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript" src="dat.gui.min.js"></script>
		<script type="text/javascript">
			var gui;
			var textGui;
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			// var helper = new THREE.CameraHelper( camera );
			var camera2 = new THREE.PerspectiveCamera( 75, 1, 0.1, 1000 );
			// var helper2 = new THREE.CameraHelper( camera2 );
			var renderer = new THREE.WebGLRenderer();
			var WORLD_SIDE_SIZE = 7;
			// scene.add( helper2 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.domElement.style.position = "relative";
			// renderer2.setSize( window.innerWidth/2, window.innerHeight );
			// renderer.setClearColor (0xaaeeff, 1); // Sky color
			document.body.appendChild( renderer.domElement );
			renderer.autoClear = false;


			// Objects
            var texture = new THREE.TextureLoader().load('box.jpg');
            var geometry = new THREE.BoxGeometry(10, 10, 10);
			var material = new THREE.MeshBasicMaterial( { map: texture } );
			var shape = new THREE.Mesh( geometry, material );
			// var floorColor = new THREE.MeshPhongMaterial({color:'#aaaaaa',wireframe:false});
			// var floor = new THREE.Mesh(new THREE.PlaneGeometry(500,500,8,8), floorColor);
			
			
			camera.position.z = 15;
			camera.position.y = 10;
			camera2.position.z = 0;
			camera2.position.y = 500;
			camera.position.x = 1;
			camera2.rotation.x = -90 * Math.PI / 180;
			// floor.position.y = 0;
			// floor.rotateX( - Math.PI / 2);


			// FLOOR ///////////////////
			// Geometry
			var cbgeometry = new THREE.PlaneGeometry( 500, 500, WORLD_SIDE_SIZE, WORLD_SIDE_SIZE )
			// Materials
			var cbmaterials = []; 
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0xff8800, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0x00ffff, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide }) );
			cbmaterials.push( new THREE.MeshBasicMaterial( { color: 0xff00ff, side: THREE.DoubleSide }) );
			nColors = cbmaterials.length;
			var l = cbgeometry.faces.length / 2; // <-- Right here. This should still be 8x8 (64)
			// console.log("This should be 64: " + l);// Just for debugging puporses, make sure this is 64
			for( var i = 0; i < l; i ++ ) {
				j = i * 2; // <-- Added this back so we can do every other 'face'
				cbgeometry.faces[ j ].materialIndex = ((i + Math.floor(i/WORLD_SIDE_SIZE)) % nColors); // The code here is changed, replacing all 'i's with 'j's. KEEP THE 8
				cbgeometry.faces[ j + 1 ].materialIndex = ((i + Math.floor(i/WORLD_SIDE_SIZE)) % nColors); // Add this line in, the material index should stay the same, we're just doing the other half of the same face
			}
			// Mesh
			cb = new THREE.Mesh( cbgeometry, cbmaterials );
			cb.rotateX( - Math.PI / 2);
			cb.position.y = 0;
			// FLOOR ///////////////////


            shape.position.y = shape.geometry.parameters.height / 2;
			scene.add( cb );
			scene.add( shape );


			function onMouseMove( event ) {
				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components
				// For selecting in menu???
				// if(event.clientX > window.innerWidth/2){
				// 	mouse.x = ( (event.clientX) / window.innerWidth ) * 4 - 3;
                // 	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				// } else {
				// 	mouse.x = -300;
				// }
			}

            var arrowMoveControls = {
                up: 38,
                down: 40,
                left: 37,
                right: 39
            };
            var wasdMoveControls = {
                up: 87,
                down: 83,
                left: 65,
                right: 68
            };
            var resetControl = 8;
            var moveControls = arrowMoveControls;

            var keyCodeMap = {};

            var speed = 0.5;

            document.addEventListener('keydown', onKeyDownUp, false);
            document.addEventListener('keyup', onKeyDownUp, false);

            function onKeyDownUp(e) {
                e = e || event; // For IE.
                keyCodeMap[e.which] = e.type === 'keydown';
            }

            function doMovementLoop() {
                if (keyCodeMap[moveControls.up]) {
                    shape.position.z -= speed;
                }
                if (keyCodeMap[moveControls.down]) {
                    shape.position.z += speed;
                }
                if (keyCodeMap[moveControls.left]) {
                    shape.position.x -= speed;
                }
                if (keyCodeMap[moveControls.right]) {
                    shape.position.x += speed;
                }
                if (keyCodeMap[resetControl]) {
                    shape.position.set(0, shape.position.y, 0);
                }
            }

            // Animate loop.

            var animate = function () {
                // window.addEventListener( 'mousemove', onMouseMove, false );
                requestAnimationFrame(animate);

                renderer.clear();

                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.render(scene, camera);

				renderer.setViewport(window.innerWidth-200,50,150,150);
				renderer.render(scene, camera2);

                doMovementLoop();
            };

			animate();
		</script>
	</body>
</html>
